"""revert_user_sync_trigger_changes

Revision ID: a1b2c3d4e5f6
Revises: f42c9c6c2096
Create Date: 2025-10-06 12:00:00.000000+00:00

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'a1b2c3d4e5f6'
down_revision: Union[str, None] = 'f42c9c6c2096'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Revert the trigger function to its original, simple state.
    op.execute("""
        CREATE OR REPLACE FUNCTION public.sync_auth_user_to_public()
        RETURNS TRIGGER AS $$
        BEGIN
            INSERT INTO public.users (id, email, created_at, updated_at)
            VALUES (NEW.id::text, NEW.email, NEW.created_at, NEW.updated_at)
            ON CONFLICT (id) DO UPDATE
            SET email = EXCLUDED.email, updated_at = EXCLUDED.updated_at;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql SECURITY DEFINER;
    """)

    # Remove the database-level default from the linked_accounts.id column.
    op.execute("""
        ALTER TABLE public.linked_accounts
        ALTER COLUMN id DROP DEFAULT;
    """)


def downgrade() -> None:
    # Step 1: Set a database-level default for the linked_accounts.id primary key.
    # This ensures the database can generate an ID when the trigger inserts a new row.
    op.execute("""
        ALTER TABLE public.linked_accounts
        ALTER COLUMN id SET DEFAULT gen_random_uuid()::text;
    """)

    # Step 2: Create the trigger function with all previous fixes included.
    # This function now relies on the database default set above.
    op.execute("""
        CREATE OR REPLACE FUNCTION public.sync_auth_user_to_public()
        RETURNS TRIGGER AS $$
        DECLARE
            app_record RECORD;
        BEGIN
            -- Sync user data to the fully qualified public.users table
            INSERT INTO public.users (id, email, created_at, updated_at)
            VALUES (NEW.id::text, NEW.email, NEW.created_at, NEW.updated_at)
            ON CONFLICT (id) DO UPDATE
            SET email = EXCLUDED.email, updated_at = EXCLUDED.updated_at;

            -- Loop through apps using the correct lowercase 'no_auth' key
            FOR app_record IN
                SELECT id FROM public.apps WHERE security_schemes ? 'no_auth'
            LOOP
                -- Check for existing accounts
                IF NOT EXISTS (
                    SELECT 1 FROM public.linked_accounts
                    WHERE user_id = NEW.id::text AND app_id = app_record.id
                ) THEN
                    -- Insert new linked account; the 'id' will be generated by the new DB default.
                    INSERT INTO public.linked_accounts (
                        user_id,
                        app_id,
                        security_scheme,
                        security_credentials,
                        disabled_functions
                    ) VALUES (
                        NEW.id::text,
                        app_record.id,
                        'NO_AUTH',
                        '{}'::jsonb,
                        ARRAY[]::text[]
                    );
                END IF;
            END LOOP;

            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql SECURITY DEFINER;
    """)